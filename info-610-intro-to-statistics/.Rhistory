table(data$trunk_wire)
# logistic model
log_model <- glm(badhealth ~ sidewalkdamage + guardrailharm + stoneproblem + grateproblem + tree_dbh + trunk_wire,
data = data, family = "binomial")
summary(log_model)
# logistic model
log_model <- glm(badhealth ~ sidewalk + guardrailharm + stoneproblem + grateproblem + tree_dbh + trunk_wire,
data = data, family = "binomial")
summary(log_model)
table(data$sidewalk)
# logistic model
log_model <- glm(badhealth ~ tree_dbh + sidewalk + guards + root_stone + root_grate + trunk_wire + trunk_light,
data = data, family = "binomial")
summary(log_model)
ls(data)
# logistic model
log_model <- glm(badhealth ~ tree_dbh + sidewalk + guards + root_stone + root_grate + trunk_wire + trnk_light,
data = data, family = "binomial")
summary(log_model)
# logistic model
log_model <- glm(badhealth ~ tree_dbh + boroname + sidewalk + guards + root_stone + root_grate + trunk_wire + trnk_light,
data = data, family = "binomial")
summary(log_model)
exp(coefficients(log_model))
library(MASS)
exp(confint.default(log_model))
# stepwise modeling
forward_model <- stepAIC(log_model, direction = "forward")
summary(forward_model)
# stepwise modeling
base_model <- glm(badhealth ~ 1)
# stepwise modeling
base_model <- glm(badhealth ~ 1, data = data, family = "binomial")
summary(base_model)
forward_model <- stepAIC(base_model, direction = "forward", scope = log_model)
summary(forward_model)
backward_model <- stepAIC(base_model, direction = "backward", scope = log_model)
summary(forward_model)
both_model <- stepAIC(base_model, direction = "both", scope = log_model)
summary(forward_model)
# stepwise modeling
base_model <- glm(badhealth ~ 0, data = data, family = "binomial")
forward_model <- stepAIC(base_model, direction = "forward", scope = log_model)
summary(forward_model)
backward_model <- stepAIC(base_model, direction = "backward", scope = log_model)
summary(forward_model)
both_model <- stepAIC(base_model, direction = "both", scope = log_model)
summary(forward_model)
# stepwise modeling
base_model <- glm(badhealth ~ 1, data = data, family = "binomial")
forward_model <- stepAIC(base_model, direction = "forward", scope = log_model)
summary(forward_model)
backward_model <- stepAIC(base_model, direction = "backward", scope = log_model)
summary(forward_model)
both_model <- stepAIC(base_model, direction = "both", scope = log_model)
summary(forward_model)
ggplot(data, aes(x= tree_dbh, fill = health)) +
geom_bar(stat = "mean")
ggplot(data, aes(x= tree_dbh, fill = health)) +
geom_bar()
ggplot(data, aes(x= boroname, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= sidewalk, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= root_stone, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= root_grate, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= trunk_wire, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= trnk_light, fill = health)) +
geom_bar(stat = "count")
# logistic model
log_model <- glm(badhealth ~ tree_dbh + boroname + sidewalk + guards + root_stone + trunk_wire,
data = data, family = "binomial")
summary(log_model)
cor.test(data$badhealth, data$tree_dbh, method = "spearman")
cor.test(data$badhealth, data$boroname, method = "spearman")
cor.test(data$badhealth, data$borocode, method = "spearman")
cor.test(data$badhealth, data$tree_dbh, method = "spearman")
cor.test(data$badhealth, data$tree_dbh)
cor.test(data$badhealth, data$sidewalk)
cor.test(data$badhealth, data$sidewalkdamage)
cor.test(data$badhealth, data$sidewalkdamage, method = c("spearman"))
cor.test(data$badhealth, data$sidewalkdamage, method = "spearman")
cor.test(data$badhealth, data$sidewalkdamage, method = "kendall")
cor.test(data$badhealth, data$tree_dbh, method = "kendall")
cor.test(data$badhealth, data$root_stone)
data <- data %>%
mutate(
goodhealth = if_else(health == "Good", 1, 0),
badhealth = if_else(health == "Good", 0, 1),
sidewalkdamage = if_else(sidewalk == "Damage", 1, 0),
guardhelpful = if_else(guards == "Helpful", 1, 0),
stonedamage = if_else(root_stone == "Yes", 1, 0),
wiredamage = if_else(trunk_wire == "Yes", 1, 0),
tree_dbh = as.numeric(tree_dbh)
)
## basic data visualizations
ggplot(data, aes(x= health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= tree_dbh, fill = health)) +
geom_bar()
ggplot(data, aes(x= boroname, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= sidewalk, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= root_stone, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= trunk_wire, fill = health)) +
geom_bar(stat = "count")
ggplot(data, aes(x= trnk_light, fill = health)) +
geom_bar(stat = "count")
cor.test(data$badhealth, data$tree_dbh, method = "kendall")
cor.test(data$badhealth, data$sidewalkdamage, method = "kendall")
data <- data %>%
mutate(
goodhealth = if_else(health == "Good", 1, 0),
badhealth = if_else(health == "Good", 0, 1),
sidewalkdamage = if_else(sidewalk == "Damage", 1, 0),
guardhelpful = if_else(guards == "Helpful", 1, 0),
stonedamage = if_else(root_stone == "Yes", 1, 0),
wiredamage = if_else(trunk_wire == "Yes", 1, 0),
tree_dbh = as.numeric(tree_dbh),
borocode = as.numeric(borocode)
)
cor.test(data$badhealth, data$guardhelpful, method = "kendall")
cor.test(data$badhealth, data$stonedamage, method = "kendall")
cor.test(data$badhealth, data$wiredamage, method = "kendall")
cor.test(data$badhealth, data$borocode, method = "kendall")
options(viewer = NULL)
library(leaflet)
m <- leaflet()
m <- addTiles(m)
m <- addProviderTiles(m, "Esri.OceanBasemap")
cols <- c("red", "navy")
data <- data %>%
mutate(
goodhealth = if_else(health == "Good", 1, 0),
badhealth = if_else(health == "Good", 0, 1),
sidewalkdamage = if_else(sidewalk == "Damage", 1, 0),
guardhelpful = if_else(guards == "Helpful", 1, 0),
stonedamage = if_else(root_stone == "Yes", 1, 0),
wiredamage = if_else(trunk_wire == "Yes", 1, 0),
tree_dbh = as.numeric(tree_dbh),
borocode = as.numeric(borocode),
longitude = as.numeric(longitude),
latitude = as.numeric(latitude)
)
m <- addCircleMarkers(m,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
m
m <- addCircleMarkers(m,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
m <- addLegend(m,
"topright",
colors = cols,
labels = c("Good", "Fair or Poor"),
title = "Tree Health",
opacity = 1
)
m <- addCircleMarkers(m,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
m <- addLegend(m,
"topright",
colors = cols,
labels = c("Good", "Fair or Poor"),
title = "Tree Health",
opacity = 1
)
m
library(leaflet)
m <- leaflet()
m <- addTiles(m)
m <- addProviderTiles(m, "Esri.OceanBasemap")
cols <- c("red", "blue")
m <- addCircleMarkers(m,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
m <- addLegend(m,
"topright",
colors = cols,
labels = c("Good", "Fair or Poor"),
title = "Tree Health",
opacity = 1
)
m
cols <- c("red", "blue", "green")
m <- addCircleMarkers(m,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$health + 1],
)
m <- addLegend(m,
"topright",
colors = cols,
labels = c("Fair or ", "Fair or Poor"),
title = "Tree Health",
opacity = 1
)
m
map <- leaflet()
map <- addTiles(map)
map <- addProviderTiles(map, "Stadia.StamenToner")
cols <- c("red", "blue")
map <- addCircleMarkers(map,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
map <- addLegend(map,
"topright",
colors = cols,
labels = c("Fair or Poor", "Good"),
title = "Tree Health",
opacity = 1
)
map
cols <- c("green", "gray")
map <- addCircleMarkers(map,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
map <- addLegend(map,
"topright",
colors = cols,
labels = c("Fair or Poor", "Good"),
title = "Tree Health",
opacity = 1
)
map
rm(map)
## now just for fun, a map...
options(viewer = NULL)
library(leaflet)
map <- leaflet()
map <- addTiles(map)
map <- addProviderTiles(map, "Stadia.StamenToner")
cols <- c("green", "gray")
map <- addCircleMarkers(map,
lng = data$longitude,
lat = data$latitude,
radius = 2.5,
color = cols[data$badhealth + 1],
)
map <- addLegend(map,
"topright",
colors = cols,
labels = c("Good", "Fair/Poor"),
title = "Tree Health",
opacity = 1
)
map
# we'll use these packages
library(dplyr)  ## for data management
library(here)  ## for creating relative file paths. It's a great resource for project-oriented workflows and reproducibility.
library(moments)  ## for calculating skewness and kurtosis metrics
# set up your working directory
## to use here, save your R script wherever you want, then open it. The following will map to whatever directory in which your script is saved.
here::i_am("Lab_03.r")
# add your data
## Get data from the most recent year of the National Household Travel Survey (https://nhts.ornl.gov/).
## I'm going to use the trips data, a record of individual trips taken by respondents.
trips <- read.csv("tripv2pub.csv") %>%
mutate(across(everything(), ~ ifelse(.x < 0, NA, .x)))  # this replaces negative values with nulls, since that's how the survey designates non-reponses.
# Part 1: Present tables that summarize trip time or distance
trips$MinuteCategory <- ifelse(trips$TRVLCMIN >= 15, 1, 0) ## I created a new variable that classifies trips as more or less than 15 minutes
table(trips$TDWKND, trips$MinuteCategory) ## crosstabulated frequency table
prop.table(table(trips$TDWKND, trips$TRVLCMIN)) ## crosstabulated density table
# Part 2: Design histograms that descriptive trip time or distance by a category (I used the weekend/workweek variable)
## one option is to use the hist() funciton in base R
## partition the plot space into one row and two columns
par(mfrow = c(1,2))
## then create the histograms
hist(trips$TRVLCMIN[trips$TDWKND == 2],
breaks = 250,  ## this parameter sets the bin sizes. More breaks = more bins, each covering a smaller range of the y axis.
xlim = range(0,120),
main = "Work Week", xlab = "Minutes", ylab = "Trips",
col = "yellow")
hist(trips$TRVLCMIN[trips$TDWKND == 1],
breaks = 250,
xlim = range(0,120),
main = "Weekend", xlab = "Minutes", ylab = "Trips",
col = "purple")
# Part 3: Interpret distributions using mean, median, standard deviation, and variance
## basic descriptives
mean(trips$TRVLCMIN[trips$TDWKND == 1])
# Part 3: Interpret distributions using mean, median, standard deviation, and variance
## basic descriptives
mean(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
median(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
sd(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
var(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
mean(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
median(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
sd(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
var(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
# or use dplyr to simplify this
summary <- trips %>%
group_by(TDWKND) %>%
summarize(mean = mean(TRVLCMIN),
median = median(TRVLCMIN),
sd = sd(TRVLCMIN),
var = var(TRVLCMIN)) %>%
mutate(
TDWKND = case_when(
TDWKND == 1 ~ "Weekend",
TDWKND == 2 ~ "Work Week"))
print(summary)
# or use dplyr to simplify this
summary <- trips %>%
group_by(TDWKND) %>%
summarize(mean = mean(TRVLCMIN, na.rm = TRUE),
median = median(TRVLCMIN, na.rm = TRUE),
sd = sd(TRVLCMIN, na.rm = TRUE),
var = var(TRVLCMIN, na.rm = TRUE)) %>%
mutate(
TDWKND = case_when(
TDWKND == 1 ~ "Weekend",
TDWKND == 2 ~ "Work Week"))
print(summary)
## add mean lines to the histograms
## then create the histograms
hist(trips$TRVLCMIN[trips$TDWKND == 2],
breaks = 250,
xlim = range(0,120),
main = "Work Week", xlab = "Minutes", ylab = "Trips",
col = "yellow")
abline(v = mean(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE), col = "blue")
hist(trips$TRVLCMIN[trips$TDWKND == 1],
breaks = 250,
xlim = range(0,120),
main = "Weekend", xlab = "Minutes", ylab = "Trips",
col = "purple")
abline(v = mean(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE), col = "orange")
# Part 4: Calculate the skewness and kurtosis of the distributions
## This calculates Pearson's Coefficient of Skewness. It ranges from -3 to +3, with directionality indicating left/right skew and magnititude quantify the degree of the skew.
skewness(trips$TRVLCMIN)
# Part 4: Calculate the skewness and kurtosis of the distributions
## This calculates Pearson's Coefficient of Skewness. It ranges from -3 to +3, with directionality indicating left/right skew and magnititude quantify the degree of the skew.
skewness(trips$TRVLCMIN, na.rm = TRUE)
skewness(trips$TRVLCMIN[trips$TDWKND == 1])
skewness(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
skewness(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
## This calculates Pearson's measure of kurtosis. It ranges around the value of 3, with 3 indicating a normal distribution, <3 indicating spikier distributions (less data in the tails), and >3 indicating flatter distributions (more data in the tails).
kurtosis(trips$TRVLCMIN, na.rm = TRUE)
kurtosis(trips$TRVLCMIN[trips$TDWKND == 1], na.rm = TRUE)
kurtosis(trips$TRVLCMIN[trips$TDWKND == 2], na.rm = TRUE)
# set up, with census API
## I'll use the same poverty and race variables that I used in Lab 4 (S1701 and B02001, respectively)
library(tidyverse)
library(tidycensus)
# set up, with census API
## I'll use the same poverty and race variables that I used in Lab 4 (S1701 and B02001, respectively)
library(dply)
## sign up for a Census API key at https://api.census.gov/data/key_signup.html
census_api_key("fd874e212346a3d3f3e27fce3fb3cc7dfce3c4e1")
# pull my variables
## find a list of variables here
variablelist <- load_variables(2023, "acs5", cache = TRUE)
## define a vector with variables
variables <- c(
PovertyRate  = "S1701_C03_046E",
Pop = "B02001_001E",
AIAN = "B02001_004E",
Asian = "B02001_005E",
Black = "B02001_003E",
NHPI = "B02001_006E",
Other = "B02001_007E",
TwoOrMore = "B02001_008E",
White = "B02001_002E")
## query the API
data <- get_acs(geography = "county",
variables = variables,
output = "wide",
year = 2022)
### or use within()
data2 <- within(data, {
AIANpct = AIAN/Pop * 100
Asianpct = Asian/Pop * 100
Blackpct = Black/Pop * 100
NHPIpct = NHPI/Pop * 100
Otherpct = Other/Pop * 100
TwoOrMorepct = TwoOrMore/Pop * 100
Whitepct = White/Pop * 100
})
### or use dplyr's mutate() functions
data <- data %>%
mutate(
AIANpct = AIAN/Pop * 100,
Asianpct = Asian/Pop * 100,
Blackpct = Black/Pop * 100,
NHPIpct = NHPI/Pop * 100,
Otherpct = Other/Pop * 100,
TwoOrMorepct = TwoOrMore/Pop * 100,
Whitepct = White/Pop * 100,
)
# Q1: plot & define a research question
## In my case: Does a lower/higher share of ___ racial group predict lower/higher rates of poverty?
## first create a scatterplot to explore
plot(x = data$Whitepct,
y = data$PovertyRate,
main = "Poverty by Race",
xlab = "% White",
ylab = "Poverty Rate",
col = 'dark red')
## then test for correlation
cor.test(data$Whitepct, data$PovertyRate)
# Q2: define a regression model, interpret coefficients
## first define a linear model
model <- lm(data$PovertyRate ~ data$Whitepct)
model
abline(model)  #add regression line to scatterplot
# Q3: evaluate the model metrics
## summary() will often generate all summary metrics for statistical tests
summary(model)
# this will also work if you want to write it long form
summary(lm(data$PovertyRate ~ data$Whitepct))
# set up, with census API
## I'll use the same poverty and race variables that I used in Lab 4 (S1701 and B02001, respectively)
library(dply)
library(tidyverse)
library(tidycensus)
## sign up for a Census API key at https://api.census.gov/data/key_signup.html
census_api_key("fd874e212346a3d3f3e27fce3fb3cc7dfce3c4e1")
## sign up for a Census API key at https://api.census.gov/data/key_signup.html
census_api_key("fd874e212346a3d3f3e27fce3fb3cc7dfce3c4e1", install = TRUE)
# pull my variables
## find a list of variables here
variablelist <- load_variables(2023, "acs5", cache = TRUE)
## define a vector with variables
variables <- c(
PovertyRate  = "S1701_C03_046E",
Pop = "B02001_001E",
AIAN = "B02001_004E",
Asian = "B02001_005E",
Black = "B02001_003E",
NHPI = "B02001_006E",
Other = "B02001_007E",
TwoOrMore = "B02001_008E",
White = "B02001_002E")
## query the API
data <- get_acs(geography = "county",
variables = variables,
output = "wide",
year = 2022)
## query the API
data <- get_acs(geography = "county",
variables = variables,
output = "wide",
year = 2023)
### or use within() from base R
data <- within(data, {
AIANpct = AIAN/Pop * 100
Asianpct = Asian/Pop * 100
Blackpct = Black/Pop * 100
NHPIpct = NHPI/Pop * 100
Otherpct = Other/Pop * 100
TwoOrMorepct = TwoOrMore/Pop * 100
Whitepct = White/Pop * 100
})
### or use dplyr's mutate() functions
data <- data %>%
mutate(
AIANpct = AIAN/Pop * 100,
Asianpct = Asian/Pop * 100,
Blackpct = Black/Pop * 100,
NHPIpct = NHPI/Pop * 100,
Otherpct = Other/Pop * 100,
TwoOrMorepct = TwoOrMore/Pop * 100,
Whitepct = White/Pop * 100,
)
# Q1: plot & define a research question
## In my case: Does a lower/higher share of ___ racial group predict lower/higher rates of poverty?
## first create a scatterplot to explore
plot(x = data$Whitepct,
y = data$PovertyRate,
main = "Poverty by Race",
xlab = "% White",
ylab = "Poverty Rate",
col = 'dark red')
## then test for correlation
cor.test(data$Whitepct, data$PovertyRate)
# Q2: define a regression model, interpret coefficients
## first define a linear model
model <- lm(data$PovertyRate ~ data$Whitepct)
model
abline(model)  #add regression line to scatterplot
# Q3: evaluate the model metrics
## summary() will often generate all summary metrics for statistical tests
summary(model)
# this will also work if you want to write it long form
summary(lm(data$PovertyRate ~ data$Whitepct))
